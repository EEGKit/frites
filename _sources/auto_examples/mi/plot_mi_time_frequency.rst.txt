.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_mi_plot_mi_time_frequency.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_mi_plot_mi_time_frequency.py:


Compute MI across time and frequencies
======================================

This example illustrates how to compute the mutual information with
time-frequency inputs (e.g time-frequency maps). Then, it uses cluster-based
to correct for multiple comparisons.


.. code-block:: default

    import numpy as np
    import xarray as xr

    from frites.dataset import DatasetEphy
    from frites.workflow import WfMi

    import matplotlib.pyplot as plt

    np.random.seed(0)








Simulate data
##############################################################################
 First, we simulate time-frequency data coming from multiple subjects with a
 variable number of trials. For a single subject, the data is based on normals
 (with an addition of noise). The regressor variable is going to be continuous
 and is also going to be a normal.


.. code-block:: default


    # dataset parameters
    n_subjects = 5
    n_freqs = 20
    n_times = 50
    n_trials = np.random.randint(50, 100, n_subjects)







function to simulate a single subject


.. code-block:: default


    def sim_single_subject(n_freqs, n_times, n_trials, noise_level=10.):
        # generate the mask modulating the amplitude of the gaussian
        t_range, f_range = np.linspace(-1, 1, n_times), np.linspace(-1, 1, n_freqs)
        x, y = np.meshgrid(t_range, f_range)
        d = np.sqrt(x * x + y * y)
        sigma, mu = 2.0, 0.0
        mask_2d = np.exp(-((d - mu) ** .5 / (2. * sigma ** .5)))
        # [0, 1] normalize the mask
        mask_2d -= mask_2d.min()
        mask_2d /= mask_2d.max()
        # turn the mask 3d
        mask_3d = np.tile(mask_2d[np.newaxis, ...], (n_trials, 1, 1))
        # generate the base data
        noise = np.random.uniform(0, noise_level, (n_trials, 1, 1))
        gauss = np.random.normal(0, 1, (n_trials))
        y = gauss.copy()
        gauss = np.tile(gauss.reshape(-1, 1, 1), (1, n_freqs, n_times))
        # data is finally defined as util signal + noise
        data = noise + gauss * mask_3d

        return data[:, np.newaxis, ...], y








simulate multiple subjects and build the dataset container


.. code-block:: default


    x, y, roi = [], [], []
    times = np.linspace(-1, 1, n_times)
    freqs = np.linspace(60, 160, n_freqs)
    for s, tr in zip(range(n_subjects), n_trials):
        # simulate the data coming from a single subject
        x_single_suj, y_single_suj = sim_single_subject(n_freqs, n_times, tr)
        # xarray conversion
        _x = xr.DataArray(x_single_suj, dims=('trials', 'roi', 'freqs', 'times'),
                          coords=(y_single_suj, ['roi_0'], freqs, times))
        x += [_x]

    # define an instance of DatasetEphy
    ds = DatasetEphy(x, y='trials', roi='roi', times='times')







Compute the mutual information
##############################################################################
 Then we compute the quantity of information shared by the time-frequency data
 and the continuous regressor


.. code-block:: default


    # compute the mutual information
    wf = WfMi(inference='ffx', mi_type='cc')
    mi, pv = wf.fit(ds, n_perm=200, mcp='cluster', random_state=0, n_jobs=1)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | Estimating MI : 0/1 [00:00<?,       ?it/s]    100%|##########| Estimating MI : 1/1 [00:00<00:00,    1.26it/s]    100%|##########| Estimating MI : 1/1 [00:00<00:00,    1.26it/s]



plot the mutual information and p-values


.. code-block:: default


    plt.figure(figsize=(10, 4))
    plt.subplot(1, 2, 1)
    mi.squeeze().plot.pcolormesh(vmin=0, cmap='inferno')
    plt.title('Mutual information')
    plt.subplot(1, 2, 2)
    pv.squeeze().plot.pcolormesh(cmap='Blues_r')
    plt.title('Significant p-values (p<0.05, cluster-corrected)')
    plt.tight_layout()
    plt.show()



.. image:: /auto_examples/mi/images/sphx_glr_plot_mi_time_frequency_001.png
    :class: sphx-glr-single-img





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.207 seconds)


.. _sphx_glr_download_auto_examples_mi_plot_mi_time_frequency.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_mi_time_frequency.py <plot_mi_time_frequency.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_mi_time_frequency.ipynb <plot_mi_time_frequency.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
